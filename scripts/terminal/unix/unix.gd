class_name Unix extends Resource
# Mimcks unix commands
# These are the most caveman spaghetti code I have ever seen or written since Yandere Simulator
const MAX_WHILE_ITERATION:int = 50
var invalid_chars: PackedStringArray = ["*", "<", ">", ":", "|", "?", "CON", "PRN", "AUX", "NUL", "LPT", ".lck"]
var parsed_input: PackedStringArray
var unsplitted_input: String
var output_str: String
var shell: Bash

func _init(_shell: Bash):
	shell = _shell

func process_input(string: String):
	if !string.is_empty():
		var splited_input = string.split(" ", false)
		unsplitted_input = string
		process_argument(splited_input)
	
func process_argument(_parsed_input: PackedStringArray):
	parsed_input = _parsed_input
	# Somehow it crashes when the terminal is empty, so this is the flextape fix
	if parsed_input.is_empty():
		return
	match parsed_input[0]:
		"clear":
			clear()
		"help":
			help()
		"ls":
			ls()
		"cd":
			cd()
		"pwd":
			pwd()
		"cat":
			cat()
		"rm":
			rm()
		"mkdir":
			mkdir()
		"neofetch":
			neofetch()
		"ssh":
			ssh()
		"exit":
			exit()
		"quit":
			exit()
		_:
			output_str = parsed_input[0]+':'+" command not found"
			
func clear():
	output_str = ""
func help():
	output_str = "Available commands:\nls\ncd\npwd\ncat\nrm\nmkdir\nssh\nneofetch\nexit"
func ls():
	clear()
	var get_dir:String = get_directory_from_parameter()
	if !get_dir.contains("error_c"):
		var dir = DirAccess.open(get_dir)
		# if null, it can't be accessed due to permission
		if dir == null:
			output_str = parsed_input[0]+':'+" permission denied"
			return
		for d in dir.get_directories():
			output_str += d + "/\n"
		for f in dir.get_files():
			output_str += f + "\n"
			output_str = output_str.replace(".lck", "/")
func cd():
	clear()
	var old_dir: String = shell.directories_string[shell.current_env]
	var long_flag: PackedStringArray = ["--help"]
	var flags: PackedStringArray = ["L", "P"]
	flags.append_array(long_flag)
	var dir = DirAccess.open(old_dir)
	var get_dir: String = get_directory_from_parameter(flags, true)
	print(get_dir)
	if !get_dir.contains("error_c"):
		var err_c = dir.change_dir(get_dir)
		# When outside the user:// folder, it returns error 31
		if err_c == 31:
			pass
		elif err_c != OK:
			output_str = parsed_input[0]+':'+" permission denied"
			dir.change_dir(old_dir)
			return
		shell.directories_string[shell.current_env] = get_dir
func pwd():
	clear()
	output_str = shell.directories_string[shell.current_env]
func cat():
	clear()
	var long_flag: PackedStringArray = ["--help"]
	var flags: PackedStringArray = ["n"]
	flags.append_array(long_flag)
	var get_file:String = get_directory_from_parameter(flags)
	if !get_file.contains("error_c") and FileAccess.file_exists(get_file):
		var file = FileAccess.open(get_file, FileAccess.READ)
		output_str = file.get_as_text()
		file.close()
	else:
		var dir = DirAccess.open(shell.directories_string[shell.current_env])
		if dir.dir_exists(get_file):
			output_str = parsed_input[0]+':'+ "'" + parsed_input[parsed_input.size() - 1] + "'" +" is a directory"
			return
		if parsed_input.size() == 1:
			return
		output_str = parsed_input[0]+':'+ "'" + parsed_input[parsed_input.size() - 1] + "'" +" No such file or directory"
		get_directory_from_parameter(flags)
func rm():
	clear()
	if parsed_input.size() == 1:
		return
	var dir: String = shell.directories_string[shell.current_env]
	var long_flag: PackedStringArray = ["--help"]
	var flags: PackedStringArray = ["r", "f"]
	flags.append_array(long_flag)
	var get_f:String = get_directory_from_parameter(flags)
	var dir_a = DirAccess.open(dir)
	# Manage star flag
	if (parsed_input[parsed_input.size() - 1].ends_with("/*") or parsed_input[parsed_input.size() - 1] == "*") and dir_a.dir_exists(get_f):
		dir_a.change_dir(get_f)
		for f in dir_a.get_files():
			if check_priv(get_f, f) != OK:
				output_str = parsed_input[0]+':'+ " cannot remove " + "'" + f + "':" +" permission denied"
			else:
				dir_a.remove(f)
		if "-r" in parsed_input:		
			for d in dir_a.get_directories():
				if OS.move_to_trash(d) != OK:
					output_str = parsed_input[0]+':' + " folder must be empty"
		return
	# Normal rm procedure
	if !get_f.contains("error_c") and FileAccess.file_exists(get_f):
		if check_priv(get_f) != OK:
			output_str = parsed_input[0]+':'+" permission denied"
			return
		dir_a.remove(get_f) # Can only delete empty folder
		return
	# If it is a folder(s)
	if dir_a.dir_exists(get_f):
		if "-r" not in parsed_input:
			output_str = parsed_input[0]+':'+ " cannot remove " + "'" + parsed_input[parsed_input.size() - 1] + "':" +" Is a directory"
			return
		dir_a = DirAccess.open(dir)
		if dir_a.remove(get_f) != OK:
			output_str = parsed_input[0]+':' + " folder must be empty"
		return
	output_str = parsed_input[0]+':'+ "'" + parsed_input[parsed_input.size() - 1] + "'" +" No such file or directory"
	get_directory_from_parameter(flags)
func mkdir():
	clear()
	var long_flag: PackedStringArray = ["--help"]
	var flags: PackedStringArray = []
	flags.append_array(long_flag)
	var get_dir: String = get_directory_from_parameter(flags, false, true)
	if !get_dir.contains("error_c"):
		var dir = DirAccess.open(get_dir)
		var splt = unsplitted_input.split("\"")
		var last_param = parsed_input[parsed_input.size() - 1]
		for c in invalid_chars:
			if c in last_param:
				output_str = parsed_input[0]+':' + "'" + last_param + "'" +" invalid path"
				return
		if parsed_input.size() == 1:
			output_str = parsed_input[0]+':' +" specify the folder name"
			return
		if '"' not in last_param:
			var param = parsed_input[parsed_input.size() - 1].split("/")
			last_param = param[param.size() - 1]
			if dir.make_dir(last_param) != OK:
				output_str = parsed_input[0]+':'+" permission denied"
			return
		if dir.make_dir(splt[1]) != OK:
			output_str = parsed_input[0]+':'+" permission denied"
func ssh():
	clear()
func get_directory_from_parameter(_flags: PackedStringArray = [], _is_cd: bool = false, _is_mk: bool = false) -> String:
	# error_c[i] -> error return
	# error_cperm -> permission error when the destined dir contains ".lck"
	var curr_dir: String = shell.directories_string[shell.current_env]
	var dir = DirAccess.open(curr_dir)
	
	if parsed_input.size() == 1:
		if _is_cd:
			output_str = parsed_input[0]+':'+" directory path is empty"
		return curr_dir

	var parameter: String = parsed_input[1]
	var i: int = 1
	# Process flags
	if !_flags.is_empty() and parameter != "-":
		while parameter.begins_with("-") and i <= MAX_WHILE_ITERATION:
			if parameter.begins_with("--"):
				if parameter not in _flags:
					output_str = parsed_input[0]+':'+" invalid option " + parameter
					output_str += "\nTry " + "'" + parsed_input[0] + " --help'" + " for more information."
					return "error_c1"
			else:
				for f in parameter:
					if f not in _flags and f != "-":
						output_str = parsed_input[0]+':'+" invalid option " + parameter
						output_str += "\nTry " + "'" + parsed_input[0] + " --help'" + " for more information."
						return "error_c2"
			i += 1
			if parsed_input.size() <= i:
				return ""
			parameter = parsed_input[i]
	# Manage quotes
	if parameter.begins_with('\"') or parameter.begins_with('"'):
		var q_pos_1: int = unsplitted_input.find('"')
		var q_pos_2: int = unsplitted_input.rfind('"')
		var new_param: PackedStringArray
		new_param = unsplitted_input.split('"')
		if q_pos_1 == -1 or q_pos_2 < 0: # No first or last quote / only 1 quote present
			output_str = parsed_input[0]+':'+" invalid path"
			return "error_c3"
		# Second index is always the parameter, probably
		# TODO: cp command will hate this
		parameter = new_param[1]
		parameter = parameter.replace('"', "")
		
	# Manage *
	if parameter.ends_with('*'):
		if parameter == "*":
			parameter = parameter.replace('*', "")
		parameter = parameter.replace('/*', "")
	# Go to root directory
	if parameter.begins_with("/"):
		match shell.current_env:
			0:
				curr_dir = shell.remote_root_dir
			1:
				curr_dir = shell.remote_root_dir
			_:
				curr_dir = shell.root_dir
		# If there is no directory input other than "root", quit
		if parameter.length() == 1:
			return curr_dir
		# Easter Egg
		if parameter == "/root/":
			return "/"
		# else, remove / from the parameter
		parameter = parameter.erase(0, 1)
	# Go to parent directory
	if parameter.begins_with("..") or parameter == "-":
		var param_splt: PackedStringArray = parameter.rsplit("/", true)
		for p in param_splt:
			if p == ".." or p == "-":
				var dir_splt: PackedStringArray = curr_dir.rsplit("/", true, 1)
				var last_dir: String = dir_splt[dir_splt.size() - 1]
				curr_dir = curr_dir.left(curr_dir.length() - last_dir.length())
				
				if curr_dir[curr_dir.length() - 1] == "/":
					curr_dir = curr_dir.left(curr_dir.length() - 1)

		# This is so caveman, fix this with better code
		parameter = parameter.replace("-", "")
		parameter = parameter.replace("..", "")
		parameter = parameter.replace("///", "/")
		parameter = parameter.replace("//", "/")
	# Normal procedure
	if !dir.dir_exists(curr_dir + parameter) or parameter == ".":
		parameter = "/" + parameter
		if !dir.dir_exists(curr_dir + parameter) or parameter == "." or parameter == "/.":
			var param_splt: PackedStringArray = parameter.rsplit("/", true, 1)
			var last_param: String = param_splt[param_splt.size() - 1]
			var new_param: String = parameter.left(parameter.length() - last_param.length())
			if FileAccess.file_exists(curr_dir + parameter):
				# If has .lck extension, no
				if check_priv(curr_dir + parameter) != OK:
					output_str = parsed_input[0]+':'+" permission denied"
					return "error_c5"
				if _is_cd:
					output_str = parsed_input[0]+':' + "'" + parsed_input[i] + "'" +" is a file"
					return "error_c4"
			else:
				if FileAccess.file_exists(curr_dir + parameter + ".lck"):
					output_str = parsed_input[0]+':'+" permission denied"
					return "error_cperm"
				if _is_cd:
					output_str = parsed_input[0]+':'+" The directory " + "'"+ parsed_input[i] + "'" +" does not exist"
					return "error_c6"
				if dir.dir_exists(curr_dir + new_param) and _is_mk:
					return curr_dir + new_param
				else:
					return "error_c7"
	return curr_dir + parameter
func check_priv(parent_dir: String = "", path: String = "") -> Error:
	var p = parent_dir + path
	if !parent_dir.is_empty() and !path.is_empty():
		p = parent_dir + "/" + path
	if DirAccess.dir_exists_absolute(p):
		return OK
	var file = FileAccess.open(p, FileAccess.READ)
	var inside_str = file.get_as_text()
	if inside_str.contains("root") or path.contains(".lck"):
		return ERR_UNAUTHORIZED
	return OK
func neofetch():
	var arch: String =("
	   /\\		arch@chan
	  /  \\		OS:			Arch-Linux
	 /\\   \\		Host:		Q25
	/      \\	Kernel:		7.0.0
   /   ,,   \\	Packages: 	203
  /   |  |  -\\	CPU: 		IBM Q 53
 /_-''    ''-_\\	
	")
	output_str = arch
func exit():
	clear()
	shell.terminal.close()
	Timemode.current_time_mode = Timemode._time_mode.NORMAL
