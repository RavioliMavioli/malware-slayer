class_name NunixCommands extends Resource
# NunixCommands (Not Unix Commands)
# Commands that mimcks unix commands
const MAX_WHILE_ITERATION:int = 50
var parsed_input: PackedStringArray
var output_str: String
var shell: BabuneBash

func _init(_shell: BabuneBash):
	shell = _shell

func process_input(string: String):
	if !string.is_empty():
		var splited_input = string.split(" ", false)
		process_argument(splited_input)
	
func process_argument(_parsed_input: PackedStringArray):
	parsed_input = _parsed_input
	match parsed_input[0]:
		"clear":
			clear()
		"ls":
			ls()
		"cd":
			cd()
		"cat":
			cat()
		"rm":
			rm()
		"neofetch":
			neofetch()
		"ssh":
			ssh()
		"exit":
			exit()
		"quit":
			exit()
		_:
			output_str = parsed_input[0]+':'+" command not found"
			
func clear():
	output_str = ""
func ls():
	clear()
	if !get_directory_from_parameter() == "":
		var dir = DirAccess.open(get_directory_from_parameter())
		for d in dir.get_directories():
			output_str += d + "/\n"
		for f in dir.get_files():
			output_str += f + "\n"
		print(get_directory_from_parameter())
func cd():
	clear()
	var curr_dir: String = shell.directories_string[shell.current_env]
	var dir = DirAccess.open(curr_dir)
	
	if parsed_input.size() == 1:
		output_str = parsed_input[0]+':'+" directory path is empty"
		return 

	var parameter: String = parsed_input[1]
	# cd defaults to -L flag, which is to handle the operand dot-dot logically
	# The other flag is -P which is physicaly handle the operand
	var i: int = 1
	while (parameter == "-L" or parameter == "-P") and i <= MAX_WHILE_ITERATION:
		i += 1
		if parameter == "-L":
			parameter = parsed_input[i]
		elif parameter == "-P":
			# TODO: idk how to program it lmao
			parameter = parsed_input[i]

	# Go to rootdirectory
	if parameter.begins_with("/"):
		match shell.current_env:
			0:
				curr_dir = shell.remote_root_dir
			1:
				curr_dir = shell.remote_root_dir
			2:
				curr_dir = shell.root_dir
			_:
				curr_dir = shell.root_dir
		# If there is no directory input other than "root", quit
		if parameter.length() == 1:
			shell.directories_string[shell.current_env] = curr_dir
			return
		# else, remove / from the parameter
		parameter = parameter.erase(0, 1)

	if parameter.begins_with(".."):
		var splt: PackedStringArray = curr_dir.rsplit("/", true, 1)
		var last_char: String = splt[splt.size() - 1]
		curr_dir = curr_dir.left(curr_dir.length() - last_char.length())
		if parameter == "..":
			shell.directories_string[shell.current_env] = curr_dir
			return
		parameter = parameter.erase(0, 3)

	if !dir.dir_exists(curr_dir + parameter) or parameter == ".":
		parameter = "/" + parameter
		if !dir.dir_exists(curr_dir + parameter) or parameter == "." or parameter == "/.":
			output_str = parsed_input[0]+':'+" The directory " + "'"+ parsed_input[i] + "'" +" does not exist"
			return
			
	shell.directories_string[shell.current_env] = curr_dir + parameter
	dir.change_dir(curr_dir + parameter)
func cat():
	clear()
	var dir = shell.directories_string[shell.current_env]
	
	if parsed_input.size() == 1:
		output_str = parsed_input[0]+':'+" file path is empty"
		return
	
	var parameter = parsed_input[1]
	
	if !FileAccess.file_exists(dir + parameter):
		parameter = "/" + parameter
		if !FileAccess.file_exists(dir + parameter):
			output_str = parsed_input[0]+':'+" No such file or directory"
			return
			
	var file = FileAccess.open(dir + parameter, FileAccess.READ)
	output_str = file.get_as_text()
	
	file.close()
func rm():
	clear()
	var dir = shell.directories_string[shell.current_env]
	
	if parsed_input.size() == 1:
		output_str = parsed_input[0]+':'+" file path is empty"
		return
	for i in parsed_input:
		if parsed_input.find(i) == 0:
			pass
		elif i == "*":
			var dir_a = DirAccess.open(dir)
			for f in dir_a.get_files():
				dir_a.remove(f)
			output_str = parsed_input[0]+':'+" deleted all files"
		else:
			var parameter = i
			
			if !FileAccess.file_exists(dir + parameter):
				parameter = "/" + parameter
				if !FileAccess.file_exists(dir + parameter):
					output_str = parsed_input[0]+': ' + '"' + i + '"' +" No such file or directory"
					return
					
			var file = DirAccess.open(dir)
			file.remove(dir + parameter)
			output_str = parsed_input[0]+': ' + '"' + i + '"' +" removed"

func ssh():
	clear()
func get_directory_from_parameter() -> String:
	##### THIS CODE IS A MODIFIED VERSION OF cd() FUNCTION #####
	var curr_dir: String = shell.directories_string[shell.current_env]
	var dir = DirAccess.open(curr_dir)
	
	if parsed_input.size() == 1:
		return curr_dir

	var parameter: String = parsed_input[1]
	# Go to root directory
	if parameter.begins_with("/"):
		match shell.current_env:
			0:
				curr_dir = shell.remote_root_dir
			1:
				curr_dir = shell.remote_root_dir
			2:
				curr_dir = shell.root_dir
			_:
				curr_dir = shell.root_dir
		# If there is no directory input other than "root", quit
		if parameter.length() == 1:
			return curr_dir
		# else, remove / from the parameter
		parameter = parameter.erase(0, 1)
	
	if parameter.begins_with(".."):
		var splt: PackedStringArray = curr_dir.rsplit("/", true, 1)
		var last_char: String = splt[splt.size() - 1]
		curr_dir = curr_dir.left(curr_dir.length() - last_char.length())
		if parameter == "..":
			return curr_dir
		parameter = parameter.erase(0, 3)
	
	if parameter == "." or parameter == "/.":
		return curr_dir
	
	if (!dir.dir_exists(curr_dir + parameter) or !dir.file_exists(curr_dir + parameter)) and !parameter.begins_with("/"):
		parameter = "/" + parameter
		if !dir.dir_exists(curr_dir + parameter) and !dir.file_exists(curr_dir + parameter):
			output_str = parsed_input[0]+':'+" The directory " + "'"+ parsed_input[1] + "'" +" does not exist"
			return ""
		
	if dir.file_exists(curr_dir + parameter):
		#var splt: PackedStringArray = curr_dir.rsplit("/", true, 1)
		#var last_char: String = splt[splt.size() - 1]
		#curr_dir = curr_dir.left(curr_dir.length() - last_char.length())
		#if !dir.dir_exists(curr_dir + parameter):
		output_str = parsed_input[0]+':'+ "'"+ parsed_input[1] + "'" +" is a file"
		return ""
	return curr_dir + parameter
func neofetch():
	var arch: String =("
	   /\\		arch@chan
	  /  \\		OS:			Arch-Linux
	 /\\   \\		Host:		Q25
	/      \\	Kernel:		7.0.0
   /   ,,   \\	Packages: 	203
  /   |  |  -\\	CPU: 		IBM Q 53
 /_-''    ''-_\\	
	")
	output_str = arch
func exit():
	clear()
	shell.terminal.close()
	Timemode.current_time_mode = Timemode._time_mode.NORMAL
