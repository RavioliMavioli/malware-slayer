class_name NunixCommands extends Resource
# NunixCommands (Not Unix Commands)
# Commands that mimcks unix commands
# These are the most caveman code I have ever seen and made since Yandere Simulator
const MAX_WHILE_ITERATION:int = 50
var parsed_input: PackedStringArray
var unsplitted_input: String
var output_str: String
var shell: BabuneBash

func _init(_shell: BabuneBash):
	shell = _shell

func process_input(string: String):
	if !string.is_empty():
		var splited_input = string.split(" ", false)
		unsplitted_input = string
		process_argument(splited_input)
	
func process_argument(_parsed_input: PackedStringArray):
	parsed_input = _parsed_input
	# Somehow it crashes when the terminal is empty, so this is the flextape fix
	if parsed_input.is_empty():
		return
	match parsed_input[0]:
		"clear":
			clear()
		"ls":
			ls()
		"cd":
			cd()
		"pwd":
			pwd()
		"cat":
			cat()
		"rm":
			rm()
		"mkdir":
			mkdir()
		"neofetch":
			neofetch()
		"ssh":
			ssh()
		"exit":
			exit()
		"quit":
			exit()
		_:
			output_str = parsed_input[0]+':'+" command not found"
			
func clear():
	output_str = ""
func ls():
	clear()
	var get_dir:String = get_directory_from_parameter()
	if get_dir != "":
		var dir = DirAccess.open(get_dir)
		# if null, it can't be accessed due to permission
		if dir == null:
			output_str = parsed_input[0]+':'+" permission denied"
			return
		for d in dir.get_directories():
			output_str += d + "/\n"
		for f in dir.get_files():
			output_str += f + "\n"
func cd():
	clear()
	var old_dir: String = shell.directories_string[shell.current_env]
	var long_flag: PackedStringArray = ["--help"]
	var flags: PackedStringArray = ["L", "P"]
	flags.append_array(long_flag)
	var dir = DirAccess.open(old_dir)
	var get_dir: String = get_directory_from_parameter(flags, true)
	if get_dir != "":
		if dir.change_dir(get_dir) != OK:
			output_str = parsed_input[0]+':'+" permission denied"
			dir.change_dir(old_dir)
			return
		shell.directories_string[shell.current_env] = get_dir
func pwd():
	clear()
	output_str = shell.directories_string[shell.current_env]
func cat():
	clear()
	var long_flag: PackedStringArray = ["--help"]
	var flags: PackedStringArray = ["n"]
	flags.append_array(long_flag)
	var get_file:String = get_directory_from_parameter(flags)
	if get_file != "" and FileAccess.file_exists(get_file):
		var file = FileAccess.open(get_file, FileAccess.READ)
		output_str = file.get_as_text()
		file.close()
	else:
		var dir = DirAccess.open(shell.directories_string[shell.current_env])
		if dir.dir_exists(get_file):
			output_str = parsed_input[0]+':'+ "'" + parsed_input[parsed_input.size() - 1] + "'" +" is a directory"
			return
		if parsed_input.size() == 1:
			return
		output_str = parsed_input[0]+':'+ "'" + parsed_input[parsed_input.size() - 1] + "'" +" No such file or directory"
		get_directory_from_parameter(flags)
func rm():
	clear()
	if parsed_input.size() == 1:
		return
	var dir: String = shell.directories_string[shell.current_env]
	var long_flag: PackedStringArray = ["--help"]
	var flags: PackedStringArray = ["r"]
	flags.append_array(long_flag)
	var get_f:String = get_directory_from_parameter(flags)
	var dir_a = DirAccess.open(dir)
	
	if get_f != "" and FileAccess.file_exists(get_f):		
		dir_a.remove(get_f)
	else:
		if dir_a.dir_exists(get_f):
			if "-r" not in parsed_input:
				output_str = parsed_input[0]+':'+ " cannot remove " + "'" + parsed_input[parsed_input.size() - 1] + "':" +" Is a directory"
				return
			dir_a.remove(get_f)
			return
		output_str = parsed_input[0]+':'+ "'" + parsed_input[parsed_input.size() - 1] + "'" +" No such file or directory"
		get_directory_from_parameter(flags)
	if parsed_input[1] == "*":
		for f in dir_a.get_files():
			dir_a.remove(f)
		for d in dir_a.get_directories():
			dir_a.remove(d)
		output_str = parsed_input[0]+':'+" deleted all files"
func mkdir():
	clear()
	var long_flag: PackedStringArray = ["--help"]
	var flags: PackedStringArray = []
	flags.append_array(long_flag)
	
	var get_dir: String = get_directory_from_parameter(flags, false, true)
	if get_dir != "":
		var dir = DirAccess.open(get_dir)
		var splt = parsed_input[parsed_input.size() - 1].split("/")
		var last_param = splt[splt.size() - 1]
		last_param = last_param.replace('"', '')
		if dir.make_dir(last_param) != OK:
			output_str = parsed_input[0]+':'+" permission denied"
func ssh():
	clear()
func get_directory_from_parameter(_flags: PackedStringArray = [], _is_cd: bool = false, _is_mk: bool = false) -> String:
	var curr_dir: String = shell.directories_string[shell.current_env]
	var dir = DirAccess.open(curr_dir)
	
	if parsed_input.size() == 1:
		if _is_cd:
			output_str = parsed_input[0]+':'+" directory path is empty"
		return curr_dir

	var parameter: String = parsed_input[1]
	var i: int = 1
	# Process flags
	if !_flags.is_empty():
		while parameter.begins_with("-") and i <= MAX_WHILE_ITERATION:
			if parameter.begins_with("--"):
				if parameter not in _flags:
					output_str = parsed_input[0]+':'+" invalid option " + parameter
					output_str += "\nTry " + "'" + parsed_input[0] + " --help'" + " for more information."
					return ""
			else:
				for f in parameter:
					if f not in _flags and f != "-":
						output_str = parsed_input[0]+':'+" invalid option " + parameter
						output_str += "\nTry " + "'" + parsed_input[0] + " --help'" + " for more information."
						return ""
					
			i += 1
			if parsed_input.size() <= i:
				return ""
			parameter = parsed_input[i]
	# Manage quotes
	if parameter.begins_with('\"'):
		var q_pos_1: int = unsplitted_input.find('"')
		var q_pos_2: int = unsplitted_input.rfind('"')
		var new_param: PackedStringArray
		new_param = unsplitted_input.split('"')
		if q_pos_1 == -1 or q_pos_2 < 0: # No first or last quote / only 1 quote present
			output_str = parsed_input[0]+':'+" invalid path"
			return ""
		# Second index is always the parameter, probably
		parameter = new_param[1]
	# Go to root directory
	if parameter.begins_with("/"):
		match shell.current_env:
			0:
				curr_dir = shell.remote_root_dir
			1:
				curr_dir = shell.remote_root_dir
			_:
				curr_dir = shell.root_dir
		# If there is no directory input other than "root", quit
		if parameter.length() == 1:
			#shell.directories_string[shell.current_env] = curr_dir
			return curr_dir
		# Easter Egg
		if parameter == "/root/":
			return "/"
		# else, remove / from the parameter
		parameter = parameter.erase(0, 1)

	if parameter.begins_with(".."):
		var param_splt: PackedStringArray = parameter.rsplit("/", true)
		for p in param_splt:
			if p == "..":
				var dir_splt: PackedStringArray = curr_dir.rsplit("/", true, 1)
				var last_dir: String = dir_splt[dir_splt.size() - 1]
				curr_dir = curr_dir.left(curr_dir.length() - last_dir.length())
				
				if curr_dir[curr_dir.length() - 1] == "/":
					curr_dir = curr_dir.left(curr_dir.length() - 1)

		# This is so caveman, fix this with better code
		parameter = parameter.replace("..", "")
		parameter = parameter.replace("//", "/")
	
	if !dir.dir_exists(curr_dir + parameter) or parameter == ".":
		parameter = "/" + parameter
		if !dir.dir_exists(curr_dir + parameter) or parameter == "." or parameter == "/.":
			var param_splt: PackedStringArray = parameter.rsplit("/", true, 1)
			var last_param: String = param_splt[param_splt.size() - 1]
			var new_param: String = parameter.left(parameter.length() - last_param.length())
			if FileAccess.file_exists(curr_dir + parameter):
				if _is_cd:
					output_str = parsed_input[0]+':' + "'" + parsed_input[i] + "'" +" is a file"
					return ""
			else:
				if _is_cd:
					output_str = parsed_input[0]+':'+" The directory " + "'"+ parsed_input[i] + "'" +" does not exist"
					return ""
			if dir.dir_exists(curr_dir + new_param) and _is_mk:
				return curr_dir + new_param
			else:
				return ""
	return curr_dir + parameter
func neofetch():
	var arch: String =("
	   /\\		arch@chan
	  /  \\		OS:			Arch-Linux
	 /\\   \\		Host:		Q25
	/      \\	Kernel:		7.0.0
   /   ,,   \\	Packages: 	203
  /   |  |  -\\	CPU: 		IBM Q 53
 /_-''    ''-_\\	
	")
	output_str = arch
func exit():
	clear()
	shell.terminal.close()
	Timemode.current_time_mode = Timemode._time_mode.NORMAL
