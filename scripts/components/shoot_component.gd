extends Node2D
#### EACH KINDS OF BULLETS MUST HAVE THEIR OWN SHOOT COMPONENT ####
@export_group("Required Nodes")
@export var projectile: PackedScene
@export var aim_center: Marker2D
@export var bullet_spawn: Marker2D

@export_group("Bullet Properties")
@export_subgroup("Pooler")
@export var pool_size_type: _pool_size = _pool_size.AUTO
@export_range(10, 10000, 1) var pool_size: int = 50
@export_subgroup("Properties")
@export var mechanism: _mechanism = _mechanism.FULLY_AUTOMATIC
@export var is_single_bullet:bool = false
@export var shoot_per_minute: int = 1000
@export_range(0.0, 10.0, 1.0) var angle_randomness:float = 0
@export_range(1, 20, 1) var bullet_ammount:int = 5
@export_range(5.0, 200.0, 5.0) var bullet_spread:float = 30.0
@export_range(1.0, 90.0, 1.0) var bullet_spread_degrees:float = 20.0
@export_range(0.1, 10.0, 0.1) var curve_factor:float = 3.0
@export var gap:bool = false

var camera_shaker: CameraShaker = CameraShaker.new()

enum _pool_size {AUTO, MANUAL}
enum _mechanism {SEMI_AUTOMATIC, FULLY_AUTOMATIC}

var bullet_pool: Array[Bullet]
var current_bullet_index: int = 0
var shoot_timer: Timer
var held_down: bool = false

func _ready():
	init_pool()
	init_timer()

func _physics_process(_delta):
	if shoot_timer.is_stopped() and held_down:
		camera_shaker.shake_short_strong()
		shoot_bullet()
		shoot_timer.start()
	match mechanism:
		_mechanism.FULLY_AUTOMATIC:
			pass
		_mechanism.SEMI_AUTOMATIC:
			held_down = false

func init_timer():
	shoot_timer = Timer.new()
	shoot_timer.autostart = false
	shoot_timer.one_shot = true
	shoot_timer.wait_time = 1.0 / (shoot_per_minute as float / 60.0)
	add_child(shoot_timer)
	
func init_pool():
	
	match pool_size_type:
		_pool_size.AUTO:
			pool_size = round(shoot_per_minute as float * bullet_ammount as float / projectile.instantiate().SPEED as float) * 25
			if pool_size <= 10:
				pool_size = 10
		_pool_size.MANUAL:
			pass
	for i in pool_size:
		var new_bullet: Bullet = projectile.instantiate()
		var parent: Node2D = get_parent().get_parent().get_node("Bullets")
		bullet_pool.append(new_bullet)
		parent.call_deferred("add_child", new_bullet)

func shoot():
	held_down = true

func unshoot():
	held_down = false
	
func remove_pool():
	for b in bullet_pool:
		if b != null:
			b.call_deferred("queue_free")
	bullet_pool.clear()

func shoot_bullet():
	var listed_gap:Array[int] = []
	if gap:
		listed_gap.append(round(bullet_ammount/2))
		if bullet_ammount %2 == 0:
			listed_gap.append(round(bullet_ammount/2) - 1)
			
	if is_single_bullet:
		var bullet: Bullet = bullet_pool[current_bullet_index]
		bullet.spawn()
		bullet.global_position = bullet_spawn.global_position
		bullet.global_rotation = bullet_spawn.global_rotation + rng()
		
		if current_bullet_index >= bullet_pool.size() - 1:
			current_bullet_index = 0
			return
		current_bullet_index += 1
		return
		
	for i in bullet_ammount:
		if !listed_gap.has(i) and !bullet_pool.is_empty():
			var bullet: Bullet = bullet_pool[current_bullet_index]
			bullet.spawn()
			bullet.global_position = bullet_spawn.global_position
			bullet.global_rotation = bullet_spawn.global_rotation
				
			var spawn_line = bullet_spread/2 - ( i * bullet_spread/(bullet_ammount-1) )
			var spawn_line_normalized = spawn_line / (bullet_spread/2)
		
			var curved_spawn_line:float
			curved_spawn_line = curve_factor * cos(spawn_line_normalized*PI/2)
		
			bullet.global_position.y += spawn_line
				
			# Rotates the whole bullets with matrix transformation, so it doesn't spawn in a straight line,
			# But rotated along the direction its facing
				
			# X = Ax + (Bx - Ax) cos a - (By - Ay) sin a
			# Y = Ay + (Bx - Ax) sin a + (By - Ay) cos a
				
			var Ax = bullet_spawn.global_position.x
			var Ay = bullet_spawn.global_position.y
			var Bx = bullet.global_position.x + curved_spawn_line
			var By = bullet.global_position.y
			var alpha = bullet.global_rotation

			var new_position:Vector2 = Vector2(	Ax + (Bx - Ax) * cos(alpha) - (By - Ay) * sin(alpha),
												Ay + (Bx - Ax) * sin(alpha) + (By - Ay) * cos(alpha))
			
			bullet.global_position = new_position
			bullet.global_rotation += deg_to_rad( bullet_spread_degrees/2 - (i * bullet_spread_degrees/(bullet_ammount-1)) ) + rng()
				
			if current_bullet_index >= bullet_pool.size() - 1:
				current_bullet_index = 0
				return
			current_bullet_index += 1

func rng() -> float:
	return deg_to_rad(randf_range(angle_randomness, -angle_randomness))
