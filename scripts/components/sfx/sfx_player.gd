class_name SFXPlayer extends Node2D

signal finished

@export var sfx_array: Array[AudioStream]
@export var autoplay: bool = false
@export var shuffle: bool = true
@export var max_polyphony: int = 5
@export var volume: float = 0.0
@export var panning_strength: float = 1.0
@export var slowmo_effect: EFFECT = EFFECT.PITCH

enum EFFECT {NONE, PITCH, LOWPASS}
var audio_streams: Array
var audio_bus: String
var index := 0

func play() -> void:
	if sfx_array.size() == 0:
		return
	if shuffle:
		index = randi_range(0, sfx_array.size() - 1)
	else:
		index = wrapi(index + 1, 0, sfx_array.size())
	audio_streams[index].play()

func destroy() -> void:
	for stream in audio_streams:
		stream.queue_free()

func is_still_playing() -> bool:
	for stream in audio_streams:
		if stream.playing:
			return true
	return false

func _ready() -> void:
	_setup_audio_bus()
	_spawn_sfx_node()
	if autoplay:
		_autoplay()

func _physics_process(delta: float) -> void:
	if slowmo_effect != EFFECT.PITCH:
		return
	for audio in audio_streams:
		if Timemode.current_time_mode == Timemode.TIME_MODE.SLOWMO:
			audio.pitch_scale = Engine.time_scale
		else:
			audio.pitch_scale = lerp(audio.pitch_scale, Engine.time_scale, delta * 10 * 1/Engine.time_scale )

func _autoplay() -> void:
	for audio in audio_streams:
		audio.play()
		await audio.finished

func _setup_audio_bus() -> void:
	match slowmo_effect:
		EFFECT.LOWPASS:
			audio_bus = Audio.get_bus_str(Audio.AUDIO_BUS.SFX_LOW_PASS)
		_:
			audio_bus = Audio.get_bus_str(Audio.AUDIO_BUS.SFX)

func _spawn_sfx_node() -> void:
	for sound in sfx_array:
		var sfx_node = AudioStreamPlayer2D.new()
		sfx_node.bus = audio_bus
		sfx_node.stream = sound
		sfx_node.volume_db = volume
		sfx_node.max_polyphony = max_polyphony
		sfx_node.panning_strength = panning_strength
		sfx_node.finished.connect(_finished)
		audio_streams.append(sfx_node)
		add_child(sfx_node)

func _finished() -> void:
	finished.emit()
