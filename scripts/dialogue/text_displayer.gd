class_name DialogueTextDisplayer extends Node2D

signal finished
signal next

const MAX_TEXT_BOX_SIZE: float = 104.0
var MIN_TEXT_BOX_SIZE: float
var INCREMENT_TEXT_BOX_SIZE: float

var speed_multiplier: float:
	get: return owner.speed_multiplier
var rich_label: RichTextLabel:
	get: return %Text
var sfx_player: SFXPlayer:
	get: return %SFXPlayer
var font_size: float:
	get: return rich_label.get("theme_override_font_sizes/normal_font_size")
var v_spacing: float:
	get: return rich_label.get("theme_override_constants/line_separation")

var active: bool = true
var speed: float = 0.1
var original_text: String
var text: String
var text_index: int
var text_length: int
var tps_timer: Timer
var delay_timer: SceneTreeTimer
var play_interval: int:
	set(val):
		play_interval = wrapi(val, 0, 2)
		if play_interval == 0 and sfx_player != null:
			sfx_player.play()

func start(_displayed_text: String) -> void:
	active = true
	text = _displayed_text
	original_text = _displayed_text
	text_index = 0
	rich_label.text = ""
	text_length = text.length()
	
	MIN_TEXT_BOX_SIZE = font_size + v_spacing
	INCREMENT_TEXT_BOX_SIZE = font_size + v_spacing
	rich_label.custom_minimum_size.y = MIN_TEXT_BOX_SIZE
	
	_setup_timer()
	_connect_timer()

func exit() -> void:
	active = false
	if tps_timer != null:
		tps_timer.stop()
	if delay_timer != null:
		delay_timer.timeout.emit()
	finished.emit()
	_disconnect_timer()

func skip() -> void:
	rich_label.text = ""
	for i in range(original_text.length()):
		original_text = _add_str_by_checking_if_the_word_after_the_next_white_space_will_create_a_new_line__if_so_replace_the_white_space_with_newline(original_text, i)
		rich_label.text += original_text[i]
	_update_label_minimum_size()
	exit()
	
func _input(event: InputEvent) -> void:
	if !owner.is_open:
		return
	if event.is_action_pressed("ui_accept") or event.is_action_pressed("Shoot_1"):
		next.emit()
		speed = 0.03
		tps_timer.wait_time = speed / speed_multiplier
		if delay_timer != null:
			delay_timer.timeout.emit()
	if event.is_action_released("ui_accept") or event.is_action_released("Shoot_1"):
		speed = 0.1
		tps_timer.wait_time = speed / speed_multiplier

func _display() -> void:
	text = _add_str_by_checking_if_the_word_after_the_next_white_space_will_create_a_new_line__if_so_replace_the_white_space_with_newline(text, text_index)
	_update_label_minimum_size()
	
	var tmp_text := text[text_index]
	rich_label.text += tmp_text
	
	if tmp_text == ".":
		_pause_timer(2.3)

	text_index += 1
	play_interval += 1
	
	if text_index >= text_length - 1: # Includes end space
		tps_timer.stop()
		finished.emit()
		active = false
		return
	
func _setup_timer() -> void:
	if tps_timer == null:
		tps_timer = Timer.new()
		add_child(tps_timer)
		tps_timer.autostart = true
		tps_timer.one_shot = false
	speed = 0.1
	tps_timer.wait_time = speed / speed_multiplier
	tps_timer.start()

func _connect_timer() -> void:
	if !tps_timer.timeout.is_connected(_display):
		tps_timer.timeout.connect(_display)
	
func _disconnect_timer() -> void:
	if tps_timer.timeout.is_connected(_display):
		tps_timer.timeout.disconnect(_display)
	
func _pause_timer(duration: float):
	tps_timer.stop()
	delay_timer = get_tree().create_timer(duration)
	await delay_timer.timeout
	tps_timer.start()

# Don't change this, and don't ask any questions.
func _add_str_by_checking_if_the_word_after_the_next_white_space_will_create_a_new_line__if_so_replace_the_white_space_with_newline(_text: String, _index: int) -> String:
	var space_end_i := _text.find(" ", _index + 1) + 1
	var old_text := rich_label.text
	var new_temp_text := ""
	var old_line_count := rich_label.get_line_count()
	var new_line_count := 0
	# Temporary put the next word to the text
	new_temp_text = _text.left(space_end_i)
	rich_label.text = new_temp_text
	# Get the line count
	new_line_count = rich_label.get_line_count()
	# Revert back to the old text
	rich_label.text = old_text
	# See if it creates a new line. If so, put a new line command before the word starts
	if new_line_count - old_line_count == 1 and _text[_index] == " ":
		_text[_index] = "\n"
	return _text
	
func _update_label_minimum_size() -> void:
	var size_y := clampf(INCREMENT_TEXT_BOX_SIZE * rich_label.get_line_count(), MIN_TEXT_BOX_SIZE, MAX_TEXT_BOX_SIZE)
	rich_label.custom_minimum_size.y = size_y
	
