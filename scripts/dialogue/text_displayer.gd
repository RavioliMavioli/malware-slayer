class_name DialogueTextDisplayer extends Node2D

signal finished
signal next

var speed_multiplier: float:
	get: return owner.speed_multiplier
var rich_label: RichTextLabel:
	get: return %Text
var img: TextureRect:
	get: return %Portrait
var character_name: Label:
	get: return %Name
var sfx_player: SFXPlayer:
	get: return %SFXPlayer
	
var speed: float = 0.1
var text: String
var text_index: int
var text_length: int
var tps_timer: Timer
var delay_timer: SceneTreeTimer
var twice: int:
	set(val):
		twice = wrapi(val, 0, 2)

func start(_displayed_text: String, _character_name: String) -> void:
	text = _displayed_text
	text_index = 0
	rich_label.text = ""
	character_name.text = _character_name
	text_length = text.length()
	if tps_timer == null:
		_setup_timer()
	tps_timer.start()

func exit() -> void:
	if tps_timer != null:
		tps_timer.stop()
	if delay_timer != null:
		delay_timer.timeout.emit()
	
func _input(event: InputEvent) -> void:
	if !owner.visible:
		return
	if event.is_action_pressed("ui_accept") or event.is_action_pressed("Shoot_1"):
		next.emit()
		speed = 0.03
		tps_timer.wait_time = speed / speed_multiplier
		if delay_timer != null:
			delay_timer.timeout.emit()
	if event.is_action_released("ui_accept") or event.is_action_released("Shoot_1"):
		speed = 0.1
		tps_timer.wait_time = speed / speed_multiplier

func _display() -> void:
	var tmp_text := text[text_index]
	_add_str_and_check_if_the_word_after_the_next_white_space_will_create_a_new_line__if_so_replace_the_white_space_with_newline()
	
	if tmp_text == ".":
		_pause_timer(2.3)
	
	text_index += 1
	
	if text_index >= text_length - 1: # Includes end space
		tps_timer.stop()
		finished.emit()
		return
	
	if twice == 0 and sfx_player != null:
		sfx_player.play()
	twice += 1
	
func _setup_timer() -> void:
	tps_timer = Timer.new()
	add_child(tps_timer)
	tps_timer.autostart = true
	tps_timer.one_shot = false
	tps_timer.wait_time = speed / speed_multiplier
	tps_timer.timeout.connect(_display)

func _pause_timer(duration: float):
	tps_timer.stop()
	delay_timer = get_tree().create_timer(duration)
	await delay_timer.timeout
	tps_timer.start()

# Don't change this, and don't ask any questions.
func _add_str_and_check_if_the_word_after_the_next_white_space_will_create_a_new_line__if_so_replace_the_white_space_with_newline() -> void:
	var space_end_i := text.find(" ", text_index + 1) + 1
	var old_text := rich_label.text
	var new_temp_text := ""
	var old_line_count := rich_label.get_line_count()
	var new_line_count := 0
	# Temporary put the next word to the text
	new_temp_text = text.left(space_end_i)
	rich_label.text = new_temp_text
	# Get the line count
	new_line_count = rich_label.get_line_count()
	# Revert back to the old text
	rich_label.text = old_text
	# See if it creates a new line. If so, put a new line command before the word starts
	if new_line_count - old_line_count == 1 and text[text_index] == " ":
		text[text_index] = "\n"
			
	rich_label.text += text[text_index]
	
