class_name DialogueTextDisplayer extends Node2D

signal finished
signal next

const MAX_TEXT_BOX_SIZE: float = 104.0
var MIN_TEXT_BOX_SIZE: float
var INCREMENT_TEXT_BOX_SIZE: float

var speed_multiplier: float:
	get: return owner.speed_multiplier
var rich_label: RichTextLabel:
	get: return %Text
var img: TextureRect:
	get: return %Portrait
var character_name: Label:
	get: return %Name
var sfx_player: SFXPlayer:
	get: return %SFXPlayer
var font_size: float:
	get: return rich_label.get("theme_override_font_sizes/normal_font_size")
var v_spacing: float:
	get: return rich_label.get("theme_override_constants/line_separation")
	
var speed: float = 0.1
var text: String
var text_index: int
var text_length: int
var tps_timer: Timer
var delay_timer: SceneTreeTimer
var play_interval: int:
	set(val):
		play_interval = wrapi(val, 0, 2)
		if play_interval == 0 and sfx_player != null:
			sfx_player.play()

func start(_displayed_text: String, _character_name: String) -> void:
	text = _displayed_text
	text_index = 0
	rich_label.text = ""
	character_name.text = _character_name
	text_length = text.length()
	
	MIN_TEXT_BOX_SIZE = font_size + v_spacing
	INCREMENT_TEXT_BOX_SIZE = font_size + v_spacing
	rich_label.custom_minimum_size.y = MIN_TEXT_BOX_SIZE
	
	if tps_timer == null:
		_setup_timer()
	speed = 0.1
	tps_timer.wait_time = speed / speed_multiplier
	tps_timer.start()
	_modify_str_by_checking_if_the_word_after_the_next_white_space_will_create_a_new_line__if_so_replace_the_white_space_with_newline()

func exit() -> void:
	if tps_timer != null:
		tps_timer.stop()
	if delay_timer != null:
		delay_timer.timeout.emit()
	finished.emit()

func skip() -> void:
	rich_label.text = text
	_update_label_minimum_size()
	exit()
	
func _input(event: InputEvent) -> void:
	if !owner.is_open:
		return
	if event.is_action_pressed("ui_accept") or event.is_action_pressed("Shoot_1"):
		next.emit()
		speed = 0.03
		tps_timer.wait_time = speed / speed_multiplier
		if delay_timer != null:
			delay_timer.timeout.emit()
	if event.is_action_released("ui_accept") or event.is_action_released("Shoot_1"):
		speed = 0.1
		tps_timer.wait_time = speed / speed_multiplier

func _display() -> void:
	var tmp_text := text[text_index]
	rich_label.text += tmp_text
	_update_label_minimum_size()
	if tmp_text == ".":
		_pause_timer(2.3)
	
	text_index += 1
	play_interval += 1
	
	if text_index >= text_length - 1: # Includes end space
		tps_timer.stop()
		finished.emit()
		return
	
func _setup_timer() -> void:
	tps_timer = Timer.new()
	add_child(tps_timer)
	tps_timer.autostart = true
	tps_timer.one_shot = false
	tps_timer.wait_time = speed / speed_multiplier
	tps_timer.timeout.connect(_display)

func _pause_timer(duration: float):
	tps_timer.stop()
	delay_timer = get_tree().create_timer(duration)
	await delay_timer.timeout
	tps_timer.start()

# Don't change this, and don't ask any questions.
func _modify_str_by_checking_if_the_word_after_the_next_white_space_will_create_a_new_line__if_so_replace_the_white_space_with_newline() -> void:
	for index in range(text_length):
		var space_end_i := text.find(" ", index + 1) + 1
		var old_text := rich_label.text
		var new_temp_text := ""
		var old_line_count := rich_label.get_line_count()
		var new_line_count := 0
		# Temporary put the next word to the text
		new_temp_text = text.left(space_end_i)
		rich_label.text = new_temp_text
		# Get the line count
		new_line_count = rich_label.get_line_count()
		# Revert back to the old text
		rich_label.text = old_text
		# See if it creates a new line. If so, put a new line command before the word starts
		if new_line_count - old_line_count == 1 and text[index] == " ":
			text[index] = "\n"
		rich_label.text += text[index]
	rich_label.text = ""
	
func _update_label_minimum_size() -> void:
	var size_y := clampf(INCREMENT_TEXT_BOX_SIZE * rich_label.get_line_count(), MIN_TEXT_BOX_SIZE, MAX_TEXT_BOX_SIZE)
	rich_label.custom_minimum_size.y = size_y
	
