class_name DialogueJSONReader extends Node2D

signal dialogue_finished

var json: JSON:
	get: return owner.json
var text_processor: DialogueTextProcessor:
	get: return %TextProcessor
	
var conditions: Dictionary
var json_dict: Dictionary
var dict_ids: Array
var id_playlist: Array[int] = [0]
var current_id: int = 0
var text: Array
var character: String

func start(ids: Array[int]) -> void:
	current_id = 0
	id_playlist = ids
	_play_conversation()

func read() -> void:
	json_dict = _read_json_as_dict(json)
	_retreive_attributes_from_dict(json_dict)

func _ready() -> void:
	if json != null:
		read()
	text_processor.finished.connect(_text_processor_finished)

func _read_json_as_dict(_json: JSON) -> Dictionary:
	var file = _json.resource_path
	var json_as_text = FileAccess.get_file_as_string(file)
	var json_as_dict = JSON.parse_string(json_as_text)
	assert(json != null, "You haven't inputed a JSON yet.")
	return json_as_dict

func _play_conversation() -> void:
	_retreive_attributes_from_dict(json_dict)
	text_processor.start(text, character)
	
func _retreive_attributes_from_dict(dict: Dictionary) -> void:
	var curr_i := id_playlist[current_id]
	dict_ids = dict["id"]
	text = dict["id"][curr_i]["text"]
	character = dict["id"][curr_i]["character"]
	conditions = dict["id"][curr_i]["conditions"]

func _text_processor_finished() -> void:
	current_id += 1
	if current_id >= id_playlist.size():
		dialogue_finished.emit()
		return
	_play_conversation()
