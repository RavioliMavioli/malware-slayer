extends Camera2D

const VERTICAL_OFFSET := -30.0
const HORIZONTAL_OFFSET := 130.0
const DM := 1.3
const MM := 4
const MAX_X := 600
const MAX_Y := 300
const ZOOM_FACTOR_NORMAL := 1.0
const ZOOM_FACTOR_ZOOMED := 2.3
var offset_x := 0.0
var camera_position: Vector2
var target_zoom: Vector2
var target_coordinate: Vector2
var global_position_dm: float
var last_player_mouse_delta: int

var player_node: PlayerInstance:
	get: return await Player.get_player_node()

func _ready() -> void:
	CAV.camera_node = self

func _physics_process(delta):
	if CAV.current_camera_mode == CAV.CAMERA_MODE.STATIC:
		return
	var player_global_position: Vector2 = player_node.global_position
	var mouse_pos: Vector2 = get_global_mouse_position()
	var d_position: Vector2 = mouse_pos - global_position
	
	# Camera follows player
	global_position = Vector2(	lerp(global_position.x, player_global_position.x + offset_x, global_position_dm)			,
								lerp(global_position.y, player_global_position.y + VERTICAL_OFFSET, global_position_dm)	)
	zoom = lerp(zoom, target_zoom, global_position_dm)
	
	match CAV.current_zoom_type:
		
		CAV.ZOOM_TYPE.NORMAL:
			last_player_mouse_delta = sign(mouse_pos.x - player_global_position.x)
			global_position_dm = delta * MM
			target_zoom = Vector2(ZOOM_FACTOR_NORMAL, ZOOM_FACTOR_NORMAL)
			target_coordinate = Vector2(0.0, 0.0)
			# Camera follows cursor
			var min_abs_d = Vector2(min(abs(d_position.x), MAX_X), min(abs(d_position.y), MAX_Y))
			
			global_position = lerp(global_position, global_position +  min_abs_d * sign(d_position), delta * DM)
				
			offset_x = lerp(offset_x, last_player_mouse_delta * HORIZONTAL_OFFSET, delta/2)
			
		CAV.ZOOM_TYPE.ZOOMED:
			global_position_dm = delta * MM / Engine.time_scale / 2
			target_zoom = Vector2(ZOOM_FACTOR_ZOOMED, ZOOM_FACTOR_ZOOMED)

			offset_x = lerp(offset_x, last_player_mouse_delta * HORIZONTAL_OFFSET / 2, delta / Engine.time_scale / 3)
