extends Camera2D

const VERTICAL_OFFSET = -30.0
const HORIZONTAL_OFFSET = 130.0
const DM = 1.3
const MM = 4
const MAX_X = 600
const MAX_Y = 300

enum zoom_type {NORMAL, ZOOMED}

@export var type: zoom_type = zoom_type.NORMAL
@onready var player:PlayerClass = get_tree().get_root().get_node(get_tree().current_scene.name +"/"+ "Player")
var offset_x: float = 0.0
var player_global_position:Vector2 = Vector2(0,0)
var camera_position: Vector2
var target_zoom: Vector2 = Vector2(1,1)

func _input(event):
	if event.is_action_pressed("Q"):
		type = wrapi(type + 1, zoom_type.NORMAL, zoom_type.size()) 
		match type:
			zoom_type.NORMAL:
				player.enable_input = player._enable_input.ENABLED
			zoom_type.ZOOMED:
				player.enable_input = player._enable_input.DISABLED
				
func _physics_process(delta):

	var mouse_pos = get_global_mouse_position()
	var d_position = mouse_pos - global_position
	
	player_global_position = player.global_position
	# Camera follows player
	global_position = Vector2(	lerp(global_position.x, player_global_position.x + offset_x, delta * MM)			,
								lerp(global_position.y, player_global_position.y + VERTICAL_OFFSET, delta * MM/2)	)
	
	zoom = lerp(zoom, target_zoom, delta * MM)
	
	match type:
		zoom_type.NORMAL:
			target_zoom = Vector2(1,1)
			# Camera follows cursor
			var abs_d = Vector2 (abs(d_position.x) , abs(d_position.y))
			
			global_position = Vector2(	lerp(global_position.x, min(abs_d.x , MAX_X) * sign(d_position.x), delta * DM)	,
										lerp(global_position.y, min(abs_d.y, MAX_Y) * sign(d_position.y), delta * DM)	)
				
			offset_x = lerp(offset_x, sign(mouse_pos.x - player_global_position.x) * HORIZONTAL_OFFSET, delta/2)
				
		zoom_type.ZOOMED:
			target_zoom = Vector2(2,2)
			offset_x = 0.0

