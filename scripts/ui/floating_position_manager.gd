class_name FloatingPositionManager extends Resource
# Manage the position of UI or other nodes that are outside the SubViewport,
# in which have to follow the nodes inside the SubViewport to behave like inside the viewport.
# Works by extracting the target node global position into canvas position,
# Then scaled, offseted, and then applied some black magic.
# This is so fucking stupid I hope there are better ways of doing this.
var floating_element: Control
var target_node: Node2D
var supposed_position: Vector2
var use_interpolation: bool
var resized_screen_center: Vector2
var screen_center: Vector2
var d_screen_center: Vector2
var offset: Vector2 = Vector2.ZERO
var target: Vector2 = Vector2.ZERO

func _init(_floating_element: Control, _target_node: Node2D = null, _use_interpolation: bool = false):
	floating_element = _floating_element
	use_interpolation = _use_interpolation
	if _target_node != null:
		target_node = _target_node

func physics(delta):
	resized_screen_center = CAV.container_default_size * CAV.viewport_container_node.scale / 2
	screen_center = CAV.screen_resolution / 2
	d_screen_center = screen_center - resized_screen_center
	offset = resized_screen_center
	if target_node != null:
		target = target_node.global_position * CAV.viewport_container_node.scale
	# Some transformation black magic fuckery
	floating_element.scale = CAV.viewport_container_node.scale
	supposed_position = (
		(-	CAV.camera_node.global_position 		*
			CAV.viewport_container_node.scale	) 	+
			d_screen_center 						+
			offset + target)
	
	if use_interpolation:
		floating_element.global_position = lerp(floating_element.global_position, supposed_position, delta * 20)
	else:
		floating_element.global_position = supposed_position
