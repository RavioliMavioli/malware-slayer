extends Node2D

var player: PlayerInstance
var player_ledge_controls: PlayerLedgeControls
var player_jump_controls: PlayerJumpControls
var player_double_jump_controls: ArchDoubleJump

@export var hook_template :PackedScene = load("res://scripts/player/characters/arch/specials/hook/hook.tscn")
@export var hook_max_length: float = 500.0
@export var hook_speed: float = 3000.0
@export var hook_retraction_speed: float = 30_000.0

@export var tension_factor: float = 50
@export var debounce_factor: float = 0.3
@export var centripedal_factor: float = 2
@export var movement_factor: float = 2
@export var damping: float = 0.5
@export var flat_damping :float = 50

@onready var hook_spawn: Marker2D
@onready var hook: Hook

var previous_hook_state
var hook_min_length := 100.0

func _ready() -> void:
	player = await Player.get_player_node()
	player_ledge_controls = player.get_node("%PlayerLedgeControls")
	player_double_jump_controls = player.get_node("%ArchDoubleJump")
	player_jump_controls = player.get_node("%PlayerJumpControls")
	hook_spawn = player.get_node("%AimCenter")
	hook = hook_template.instantiate() as Hook
	Levels.instance.add_child(hook)

func _input(event: InputEvent) -> void:
	if event.is_action_pressed("Jump"):
		_retract_hook()
	if Player.enable_input == Player.ENABLE_INPUT.DISABLED:
		return
	if event.is_action_pressed("Specials"):
		_shoot_hook()

func _physics_process(delta: float) -> void:
	if hook.hook_state == hook.HOOK_STATE .HOOKED:
		Player.enable_input = Player.ENABLE_INPUT.DISABLED
		player_ledge_controls.toggle_ledge_detector(false)
		player_ledge_controls.release()
		player_double_jump_controls.reset_jump(false)
		_move_mid_air(delta)
	if previous_hook_state == hook.HOOK_STATE.HOOKED and hook.hook_state != hook.HOOK_STATE.HOOKED:
		Player.enable_input = Player.ENABLE_INPUT.ENABLED
		player_ledge_controls.toggle_ledge_detector(true)
	previous_hook_state = hook.hook_state
	

func _shoot_hook() -> void:
	hook.speed = hook_speed
	hook.retraction_speed = hook_retraction_speed
	hook.max_length = hook_max_length
	hook.min_length = hook_min_length
	hook.shoot(hook_spawn.rotation, hook_spawn)
	
func _retract_hook() -> void:
	if hook.hook_state == hook.HOOK_STATE.HOOKED:
		player_double_jump_controls.reset_jump(true)
		hook.retract()
		if abs(player.velocity.y) <= 400.0:
			player_jump_controls.jump()
	
func _move_mid_air(delta):
	
	var running_speed := player.get_node("%PlayerMovementControls").running_speed as float
	var direction := Vector2 (Input.get_axis("Left", "Right"), Input.get_axis("Up", "Down"))
	player.velocity += direction * running_speed * movement_factor * delta
	
	var force := _get_force()
	player.velocity += hook.delta_tip_position.normalized() * force * delta
	var dampedVelocity := player.velocity * damping
	player.velocity -= dampedVelocity * delta
	player.velocity = player.velocity.move_toward(Vector2.ZERO, flat_damping*delta)

func _get_force() -> float:
	var hook_length := hook.delta_tip_position.length()
	var length_diff := hook_length - hook.attached_length
	if length_diff < 0:
		return 0
	var tension_force := length_diff * tension_factor
	
	var dir := hook.delta_tip_position.normalized()
	var parallel_velocity := dir.dot(player.velocity)
	var debounce_force := -parallel_velocity * debounce_factor
	debounce_force = maxf(debounce_force, 0)
	
	var perpendicular := Vector2(-dir.y, dir.x)
	var perpendicular_velocity := perpendicular.dot(player.velocity)
	
	var centripedal_force := absf(perpendicular_velocity) * centripedal_factor
	
	return tension_force + debounce_force + centripedal_force
