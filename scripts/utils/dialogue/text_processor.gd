class_name DialogueTextProcessor extends Node2D

signal finished

const HALT := "%p"
const SUBSTITUTION := "%v"

var text_displayer: DialogueTextDisplayer:
	get: return %TextDisplayer
var skip_button: Button:
	get: return %Skip
var portrait: TextureRect:
	get: return %Portrait
var name_label: Label:
	get: return %Name
	
var arr_text: Array
var displayed_text: String
var arr_text_index: int
var character: String
var expression: String
var variables: Dictionary
var skip_cooldown: SceneTreeTimer
var old_portrait: Texture2D
var halts: Array[int]
	
func start(_arr_text: Array, _character: String, _expression: String, _variables: Dictionary) -> void:
	character = _character
	expression = _expression
	variables = _variables
	arr_text_index = 0
	arr_text = _arr_text
	_create_space_at_the_end_of_every_str_arr()
	displayed_text = arr_text[arr_text_index]
	_set_name_label()
	_set_portrait()
	_animate_in_portrait()
	_start_displayer()
	
func exit() -> void:
	text_displayer.exit()

func _ready() -> void:
	text_displayer.finished.connect(_text_finished)
	skip_button.button_down.connect(_skip)

func _text_finished() -> void:
	await text_displayer.next
	skip_cooldown = get_tree().create_timer(0.1)
	if text_displayer.active:
		return
	arr_text_index += 1
	if arr_text_index >= arr_text.size():
		finished.emit()
		return
	displayed_text = arr_text[arr_text_index]
	_start_displayer()

func _create_space_at_the_end_of_every_str_arr() -> void:
	# a little bit of hack
	for s in arr_text:
		if s[s.length() - 1] != " ":
			var i := arr_text.find(s)
			arr_text[i] += " "

func _start_displayer() -> void:
	_get_halts()
	_variable_substitution()
	text_displayer.start(displayed_text, halts)

func _variable_substitution() -> void:
	var subs_pos: Array[int] = []
	var var_node
	var var_property
	if variables.node == "":
		return
	var_node = str_to_var("Resource(\"" + variables.node + "\")")
	if var_node == null:
		return
	var_property = var_node.instance.get(variables.variable)
	if var_property == null:
		var_property = var_node.instance.call(variables.variable.left(-2))
	if _check_var_type(var_property):
		var_property = round(var_property)
	while displayed_text.contains(SUBSTITUTION):
		subs_pos.append(displayed_text.find(SUBSTITUTION))
		displayed_text = displayed_text.erase(subs_pos.back(), 2)
	for i in subs_pos:
		displayed_text = displayed_text.insert(i, str(var_property))

func _get_halts() -> void:
	halts = []
	while displayed_text.contains(HALT):
		halts.append(displayed_text.find(HALT))
		displayed_text = displayed_text.erase(halts.back(), 2)

func _set_name_label() -> void:
	var upped_name := character.to_upper()
	var name_container = name_label.get_parent()
	if _is_name_exist(upped_name):
		name_container.show()
		name_label.text = character
		return
	name_label.text = ""
	name_container.hide()

func _set_portrait() -> void:
	var upped_name := character.to_upper()
	var upped_expression := expression.to_upper()
	var portrait_container = portrait.get_parent().get_parent()
	if !_is_name_exist(upped_name):
		portrait.texture = null
		portrait_container.hide()
		return
	assert(_is_expression_exist(upped_name, upped_expression), "Character expression not found.")
	var tex_path = Portrait.characters[upped_name][upped_expression]
	old_portrait = portrait.texture
	portrait.texture = load(tex_path)
	portrait_container.show()

func _animate_in_portrait() -> void:
	if portrait.texture == null:
		return
	if old_portrait == portrait.texture:
		return
	var init_pos := portrait.position
	var tween_pos: Tween = get_tree().create_tween()
	var tween_op: Tween = get_tree().create_tween()
	const DUR := 0.33
	portrait.position.x -= 10.0
	portrait.modulate.a = 0.0
	tween_pos.tween_property(portrait, "position", init_pos, DUR).set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_QUART)
	tween_op.tween_property(portrait, "modulate:a", 1.0, DUR).set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_QUART)
	
func _is_name_exist(_name) -> bool:
	for c in Portrait.characters:
		if Portrait.characters.has(_name):
			return true
	return false

func _is_expression_exist(_name: String, _expression: String) -> bool:
	for e in Portrait.characters[_name]:
		if Portrait.characters[_name].has(_expression):
			return true
	return false

func _check_var_type(what) -> bool:
	return typeof(what) != Variant.Type.TYPE_BOOL and typeof(what) != Variant.Type.TYPE_STRING

func _skip() -> void:
	if text_displayer.rich_label.text.length() == displayed_text.length():
		text_displayer.next.emit()
		return
	if skip_cooldown != null and skip_cooldown.time_left != 0.0:
		return
	text_displayer.skip()
